{"name":"Dulanism.github.io","tagline":"Documentation \"Mini-festo\"","body":"# Documentation\r\n\r\n**based on material by Anthony Scopatz**\r\n\r\nJust like version control and testing, documenting your code is the most\r\nimportant thing you can do as a software developer. As we have seen in\r\nprevious sessions with other tools, good documentation is a sublime\r\nexperience that should permeate your code.\r\n\r\nDocumentation is important because it is [the only way that 90% of\r\npeople will ever interact with you or your\r\ncode](http://blip.tv/pycon-us-videos-2009-2010-2011/pycon-2011-writing-great-\r\ndocumentation-4899042).\r\nIn fact, it is the only way that scales up; there are only so many\r\nemails that you can write.\r\n\r\nWhat is disturbing is that documentation is a forgotten after thought\r\nfor most developers. It turns out that being able to write software and\r\nbeing able to write in your primary spoken language are different\r\nskills. Luckily, we are academics so it is in our nature to publish /\r\nwrite. We have no excuse for bad documentation.\r\n\r\n## The Many Stages of Documentation\r\n\r\n1.  Code Comments\r\n2.  API Documentation\r\n3.  Auto-Documentation\r\n4.  Self-Documenting Code\r\n5.  Readmes\r\n6.  User Guides\r\n7.  Developer Guides\r\n\r\n\r\n\r\n## Code Comments\r\n\r\nEvery language has a special character (or two) that indicate(s) to the\r\nparser, compiler, or interpreter that whatever comes after or between\r\nthese characters should be ignored. This allows the author to write\r\nannotate and explain the code that they are writing *right at the point\r\nthat they are writing it!* This is especially helpful if something\r\nweird, obtuse, or obscure is about to happen because it gives the author\r\na chance to explain themselves to future developers (often themselves in\r\n1, 2, 6 months).\r\n\r\nThe best part is that you can put literally *anything* in comments:\r\npublication citations, ASCII art, messages to lost loves, and threats to\r\nyour collaborators.\r\n\r\nIn Python, the comment character is the hash symbol `#`. The following\r\nexample shows how you might help explain a toaster:\r\n\r\nIn[ ]:\r\n\r\n```\r\ndef toast(slices, toastiness, msg=None):\r\n    # make sure the toaster has the right setting\r\n    toastiness = int(toastiness) if 0 < toastiness else 5\r\n\r\n    print \"Engage the bread warming!\"\r\n    for slice in slices:\r\n        slice.toast(toastiness)\r\n\r\n    # log the message, making a default if needed\r\n    if msg is None:\r\n        msg = \"Toasted to level {}\".format(toastiness)\r\n    logging.info(msg)\r\n```\r\n\r\nHowever, it is certainly possible to over-document your code with\r\ncomments. Comments should never simply repeat what the code itself is\r\ndoing. The goal is to strike the right balance. The appropriate ratio\r\nchanges with language. (Typically higher level languages have greater\r\nfunctionality per line and so have more comments.) Try to avoid the\r\nfollowing:\r\n\r\nIn[ ]:\r\n\r\n```\r\n# init a to 0\r\na = 0\r\n\r\n# make b 'a string'\r\nb = 'a string'\r\n\r\n# Add one to a\r\na = a + 1\r\n\r\n# stopping excessive comments\r\nself.fall_on_sword()\r\n```\r\n\r\n## API Documentation\r\n\r\nThe application programming interface (API) is the definition of the\r\nprotocol that two pieces of code may use to interact with one another.\r\nConsider the case of functions. All functions have a function signature\r\nthat specifies how many arguments they accept and their return values.\r\nThis signature along with the module name and function name is the API.\r\n(The function object/pointer itself is the implementation and is\r\nindependent of the abstract API.)\r\n\r\nJust because you have an argument list, however, does not imply that the\r\nmeaning of the arguments is known. For example:\r\n\r\nIn[ ]:\r\n\r\n```\r\ndef f(a, b=10):\r\n    # ...\r\n    return\r\n```\r\n\r\nWe know that `f()` accepts two argument `a` and `b` and that `b` should\r\nprobably be an integer. But what does `f()` actually do? What do these\r\narguments mean in this context?\r\n\r\nPython allows the user to define API documentation right at the\r\nfunction, class, module, or variable definition. Every Python object may\r\nhave an `__doc__` attribute that is a string representation of the API\r\ndocs. This is known as a *docstring*.\r\n[PEP257](http://www.python.org/dev/peps/pep-0257/) describes the\r\nconventions for docstrings. The most important of these is that simple\r\nthings should have simple docstrings.\r\n\r\nRight below a definition, if the first non-comment, non-whitespace line\r\nis an unassigned string literal, then this string is automatically\r\nloaded in as the docstring. It is this docstring that is then read by the\r\n`help()` built-in or the `?` in IPython.\r\n\r\nIn[ ]:\r\n\r\n```\r\ndef mean(numlist):\r\n    \"\"\"Computes the mean of a list of numbers.\"\"\"\r\n    try:\r\n        total = sum(numlist)\r\n        length = len(numlist)\r\n    except ValueError:\r\n        print \"The number list was not a list of numbers.\"\r\n    except:\r\n        print \"There was a problem evaluating the number list.\"\r\n    return total/length\r\n\r\n\r\ndef fib(n):\r\n    \"\"\"Determines the nth Fibonacci number where n is \r\n    a non-negative integer.\r\n    \"\"\"\r\n    if n < 0 or int(n) != n:\r\n        return NotImplemented\r\n    elif n == 0 or n == 1:\r\n        return n\r\n    else:\r\n        return fib(n - 1) + fib(n - 2)\r\n\r\nprint help(mean)\r\nprint fib.__doc__\r\n```\r\n\r\nMost Python docstrings are written in a markup language called\r\n[reStructuredText](http://sphinx.pocoo.org/rest.html) (rST). It is\r\ndesigned to be easy to read, extensible, and provide enough\r\nnatural-looking syntax to be able to render nicely. For example, our\r\ntoaster docstring might look like:\r\n\r\nIn[ ]:\r\n\r\n```\r\ndef toast(slices, toastiness, msg=None):\r\n    \"\"\"Toast some bread.\r\n\r\n    Parameters\r\n    ----------\r\n    slices : sequence of instance of partial bread\r\n        Slices to toast to toastiness level\r\n    toastiness : int\r\n        The desired toaster setting\r\n    msg : str, optional\r\n        A message for the toaster's usage log.\r\n\r\n    \"\"\"\r\n    # make sure the toaster has the right setting\r\n    toastiness = int(toastiness) if 0 < toastiness else 5\r\n\r\n    print \"Engage the bread warming!\"\r\n    for slice if slices:\r\n        slice.toast(toastiness)\r\n\r\n    # log the message, making a default if needed\r\n    if msg is None:\r\n        msg = \"Toasted to level {}\".format(toastiness)\r\n    logging.info(msg)\r\n```\r\n\r\n## Auto-Documentation\r\n\r\nAutomatic documentation is the powerful concept that the comments and\r\ndocstrings that the developer has already written can be scraped from\r\nthe code base and placed on a website or into API documentation. This\r\nsignificantly reduces the overhead of having to write and maintain many\r\ndocuments that contain effectively the same information.\r\n\r\nProbably the three most popular auto-doc projects are\r\n[javadoc](http://www.oracle.com/technetwork/java/javase/documentation/index-\r\njsp-135444.html)\r\nfor Java, [Doxygen](http://www.stack.nl/~dimitri/doxygen/) for most\r\ncompiled languages, and [sphinx](http://sphinx.pocoo.org/) for Python.\r\n\r\n\r\n\r\n\r\n\r\n**Example:** Let's try to make some documentation using Doxygen and the example\r\nfile `multilevel_solver.py`.\r\n\r\n## Exercise\r\n\r\nYou can build the Doxygen documentation by making a stub Doxygen file for your\r\npython code. In the directory in which your code resides\r\n\r\n     doxygen -g doc_example\r\n\r\nNow you have a Doxygen template called doc_example. Open the doc_example file.\r\nThere are many entries you can edit. The ones we're going to worry about here:\r\n\r\n 1) Let's change the project name\r\n\r\n      PROJECT_NAME           = \"Multilevel Solver\"\r\n\r\n 2) Tell Doxygen what files to use\r\n\r\n      INPUT                  =  \"multilevel_solver.py\"\r\n\r\n 3) Tell it to optimize for Python\r\n\r\n      OPTIMIZE_OUTPUT_JAVA   = YES\r\n\r\n\r\nInformation about formatting Doxygen comments for Python can be found\r\n[here](http://www.stack.nl/~dimitri/doxygen/manual/docblocks.html#pythonblocks)\r\n\r\nLet's build what we've got now and check it out\r\n\r\n     doxygen doc_example\r\n     cd html\r\n     google-chrome index.html\r\n\r\n\r\nAdd some additional Doxygen formatted comments to the functions in the\r\n`multilevel_solver.py` module. Then,\r\nusing Doxygen, generate a website that auto-documents this module.\r\n\r\n## Self-Documenting Code\r\n\r\nMuch like in testing where you can simply write perfect code the first\r\ntime, there is an analogous philosophy is documentation. This is the\r\nphilosophy of [self-documenting\r\ncode](http://c2.com/cgi/wiki?SelfDocumentingCode). This ethos makes the\r\nclaim that it is often possible to write code in such a way that new\r\nreaders can understand what the code does simply by reading it.\r\nTherefore, no extra documentation is required. It is all there in the\r\ncode itself.\r\n\r\nWhile there are obvious pitfalls with this approach (assumed knowledge\r\non the reader's behalf, unavoidable complexities, etc.) there are some\r\nmerits. By having meaningful naming conventions and structure it does\r\nbecome possible to infer a lot about a code just by glancing at it.\r\nCoding standards come from the same desire to have readable software.\r\n\r\nHowever using this documentation strategy exclusively is *highly*\r\ninadvisable.\r\n\r\n## Readmes\r\n\r\nThe omnipresent `README` file is typically a plain text file that sits\r\nnext to the code. They typically may contain markup but are often quite\r\nterse. The point of a readme file is to provide only the most basic of\r\ninformation to the user / developer.\r\n\r\nReadme files are so common that GitHub will render and display the\r\nreadme file for all directories whenever you are browsing a source tree.\r\nEven Linux itself has a readme:\r\n\r\n> Linux kernel release 3.x <https://www.kernel.org/pub/linux/kernel/README>\r\n>\r\n> These are the release notes for Linux version 3. Read them carefully,\r\n> as they tell you what this is all about, explain how to install the\r\n> kernel, and what to do if something goes wrong.\r\n>\r\n> WHAT IS LINUX?\r\n>\r\n> Linux is a clone of the operating system Unix, written from scratch\r\n> by Linus Torvalds with assistance from a loosely-knit team of\r\n> hackers across the Net. It aims towards POSIX and Single UNIX\r\n> Specification compliance.\r\n>\r\n> It has all the features you would expect in a modern fully-fledged\r\n> Unix, including true multitasking, virtual memory, shared libraries,\r\n> demand loading, shared copy-on-write executables, proper memory\r\n> management, and multistack networking including IPv4 and IPv6.\r\n>\r\n> It is distributed under the GNU General Public License - see the\r\n> accompanying COPYING file for more details.\r\n>\r\n> ...\r\n\r\n## User's Guides\r\n\r\nThe next level of documentation are user's guides. These often take the\r\nform of books or pdfs that aim to explain top level architecture and\r\nfunctionality to possibly novice users. Such documents are extremely\r\nhelpful for bringing in new members to the community, going in depth\r\ninto the theory (math, biology, physics, chemistry, engineering), and as\r\na reference manual for advanced users and developers. However because of\r\ntheir high level nature, you typically have to wait until the code has\r\nstabilized to be able to write a good comprehensive user's guide.\r\n\r\n**Examples:**\r\n[FLASH](http://flash.uchicago.edu/site/flashcode/user_support/flash4b_ug.pdf),\r\n[NumPy](http://docs.scipy.org/doc/numpy/user/).\r\n\r\n## Developer Guides\r\n\r\nDeveloper guides are very similar to user's guides except that they\r\nassume a basic mastery of the project. They are typically for people who\r\nwant to *become* developers on a project rather than for existing\r\ndevelopers. They are probably most important for code projects that have\r\nplugin architectures and where the line between user and developer is\r\nless well defined.\r\n\r\n**Examples:** [Android](http://developer.android.com/guide/index.html),\r\n[Python](http://docs.python.org/devguide/).","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}